2013 年“数据结构与 C程序设计 ”( 代码 991)试题参考答案
一、单项选择题
1．C 2 ．A 3 ．D 4 ．B 5 ．C 6 ．B 7 ．D 8 ．A 9 ．C 10 ．D
二、填空题
1．顺序 2 ．O(m) 3 ．log2k+1 4 ．235 5 ．2&#61620;(n-1) 6 ．该有向图中不存在
回路 7 ．2.9 8 ．m-1 9 ．插入排序法 10 ．9
三、综合题
1．答：（1 ）多个堆栈共享一个连续的存储空间，可以充分利用存储空间，只有在整个存储空间都用完时
才能产生溢出，其缺点是当一个堆栈溢出时需要向左、右栈查询有无空闲单元。若有，则需要移动相应元
素和修改相关的栈底和栈顶指针的位置。当各个堆栈接近溢出时，查询空闲单元、移动元素和修改栈底栈
顶指针位置的操作频繁，计算复杂，并且耗费时间。
（2 ）每个堆栈仅用一个顺序存储空间时， 操作简便。但难以确定初始分配存储空间的大小， 空间分配少了，
容易产生溢出，空间分配多了，容易造成空间浪费；并且各个堆栈不能共享空间。
（3 ）一般情况下，分别建立多个链接堆栈不考虑堆栈的溢出（仅受用户内存空间限制） ，缺点是堆栈中各
元素要通过指针链接，比顺序存储结构多占用存储空间。
2．(T->lchild==NULL && T->rchild==NULL)
T->lchild
T->rchild
3．（由于图表显示限制，此题答案见指定教材 (《数据结构教程第二版》 (2012 年 4 月第 7 次印刷 )) 第
418 页 8-16 题）
4．
(1) ．根据 α=散列表中存入的元素数 / 散列表的长度，得到表的长度为 18 ，因此，合适的散列函数应该为
H(k)=k MOD 17 。
(2) ．（由于图表显示限制，此题答案见指定教材 (《数据结构教程第二版》 (2012 年 4 月第 7 次印刷 )) 第
428 页 9-15 题）
四、算法设计题
SORT(int A[ ], int n)
{ int ,i, j, min, max, temp;
i=1;
while(i<=n/2){
min=i;
max=i;
for(j=i+1;j<n-i+1;j++){
if(A[j]<A[min])
min=j;
if(A[j]>A[max])
max=j;
} /*  确定某趟排序的最小值元素和最大值元素 */
if(min!=i){
temp=A[min]; A[min]=A[i]; A[i]=temp;
} /*  交换 A[min] 与 A[i] 的位置 */
if(max!=n-i+1)
if(max==i){
temp=A[min]; A[min]=A[n-i+1]; A[n-i+1]=temp;
} /*  交换 A[min] 与 A[n-i+1] 的位置 */
else{
temp=A[max]; A[max]=A[n-i+1]; A[n-i+1]=temp;
/* 交换 A[max] 与 A[n-i+1] 的位置 */
}
i++;
}
}
五、填空题
1．break a/q 2 ．a[n-1]>=a[n-2] FUNC2(a, n-1) 3 ．(*(a+i)+i) (*(a+i)+N-i-1) 4 ．i!=0
n%10+′ 0′ 5 ．ch-=30 ch-=26
6．*(s+i) t++ 7 ．strlen(p)-1 p<q 8 ．ch& 24 9 ．4 &number 10 ．argv[1], “ rb ” argv[2],
“ wb”
六、简答题
1．答：通常有下列三种方式：
(1) 参数传递方式：函数调用时根据实参传递给形参内容的不同又分为值传递与地址传递两种。
(2) 通过 return 语句传递数据：被调用函数可以通过 return 语句将函数值传递给调用函数。
(3) 利用全局变量传递数据。
2．答：指针可以进行下列三种运算：
(1) 指针加 / 减一个整数。表示以当前指针所指单元的地址为起点的后或前整数个数据的地址。
(2) 指针减指针。表示两个地址之间的数据个数。 （指针加指针为非法运算）
(3) 比较。表示同类型的两个指针所指对象在地址位置上的关系。
3．答：共用体具有以下三个特征：
(1) 共用体变量的成员共用一块存储空间，共用体变量所占用的字节数等于最长成员所占用的字节数；
(2) 共用体不能在定义时进行初始化；
(3) 共用体中的成员每次只能有一个起作用，当存入新成员时，原来的成员失效，其值被覆盖。
4．答：使用文件的基本操作一般有下列五个步骤：
(1) 在程序中包含头文件 stdio.h
(2) 定义文件指针。例如： FILE *fp;
(3) 打开文件，使文件指针与磁盘中的实际存储的数据文件建立关联。例如：
fp=fopen( “ test.txt ” , “ r ” );
(4) 对文件进行读写操作。例如： fread(f, 4, 2, fp);
(5) 文件使用完毕后，关闭文件。例如： fclose(fp);
七、程序设计题
#include <stdio.h>
main( )
{ int a[100], i, *p, k=0;
p=a;
for(i=0; i<100; i++)
scanf( “ %d” , p+i); /* 对数组进行数据输入 */
for(i=1; i<100; i++) /*  找出最小值元素，并记录其位置 */
if(*(p+k)>*(p+i))
k=i;
for(i=k; i<99; i++)  /*  删除最小值元素 */
*(p+i)=*(p+i+1);
for(i=0; i<99; i++)  /*  输出处理后数组各元素 */
printf( “ %d” , *(p+i));
printf( “ n” );
}
八、程序设计题
函数的基本思想：
从左至右顺序扫描字符串 s，逐个找出单词，并记录单词的开始位置与单词的长度；若该单词的长度比已
找到的单词更长， 则从左至右顺序扫描字符串 t；当在字符串 t 中找到与在 s 中找到的当前最长单词相匹配
的单词时，记录单词的开始位置与单词的长度，并回到字符串 s，在其中找出下一个更长的单词。如此下
去，只至字符串 s 扫描结束，最后返回相应结果。
#include <stdio.h>
#include <string.h>
char *maxword(char *s, char *t)
{ char res, *temp, chs, cht;
inti, j, found, maxlen=0;
while(*s!=, 0?){
while(*s==, ?)
s++; /*  过滤 s 中的空格 */
for(i=0; s[i]!=, ?&&s[i]!=, 0?; i++) /*  确定 s 中单词 */
if(i>maxlen){
chs=s[i];
s[i]=, 0?;
temp=t;
found=0;
while(*temp!=, 0?&&!found){
while(*temp== , ?)
temp++; /*  过滤 t 中的空格 */
for(j=0;temp[j]!=, ?&&temp[j]!=, 0?;j++) /*  确定 t 中单词 */
if(j==i){
cht=temp[j];
temp[j]=, 0?;
if(strcmp(s, temp)==0){
maxlen=i;
res=s;
found=1
}
temp=cht;
}
temp=&temp[j]; /*  回到字符串 t 的某一位置 */
}
s[i]=chs;
}
s=&s[i]; /*  回到字符串 s 的某一位置 */
}
if(maxlen==0)
return NULL; /*  未找到最长公共单词，返回 NULL */
else{
res[maxlen+1]=, 0?;
return res; /*  找到最长公共单词，返回该单词 */
}
}